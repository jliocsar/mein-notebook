fs from node:fs
path from node:path
{ argv, stdout, exit } from node:process

type { ArgumentsCamelCase } from yargs
yargs from yargs/yargs
dayjs from dayjs
// @ts-expect-error - no types
cliMd from cli-markdown
* as C from colorette
{ hideBin } from yargs/helpers
type { ObjectId } from mongodb

{ upgrade } from ./upgrade.civet
{ createClient } from ./lib/db/client.civet
{ Prompt } from ./lib/prompt.civet
{ authInstance } from ./lib/auth.civet
{ logger } from ./lib/logger.civet
{ openOnEditor } from ./lib/editor.civet
{
  BANNER
  DATABASE_CONFIG_PATH
  OPTIONS_FILE
  SECRET
} from ./lib/const.civet

type WithId<T> =
  T &
    id: ObjectId

type NotizOptions
  editor: string

prompts := new Prompt

unless SECRET
  logger.error `No env. variable ${C.blueBright 'NOTIZ_SECRET'} detected!`
  stdout.write 'Set it to a secret string to encrypt your database auth\n'
  exit 1

choices := ['id', 'content', 'createdAt', 'expiresAt']
noop : boolean .= false

process.on 'SIGINT', ->
  logger.error 'Aborting...'
  exit 0

auth := : Promise<void> ->
  return if noop
  stdout.write BANNER + '\n'
  logger.warn 'WARN!'
  stdout.write 'No database config found, asking for one...\n\n'
  uri := prompts.secret 'URI of the database\n '
    |> await
    |> .trim()
  unless uri
    logger.error 'No URI entered'
    exit 1
  stdout.write '\n'
  try
    await authInstance.createDbCredentials uri
    noop = true
    logger.success 'Database config saved...'
  catch error
    logger.error 'Failed to write database config'
    logger.error (error as Error).message
    exit 1

unless fs.existsSync DATABASE_CONFIG_PATH
  await auth()

type Note
  content: string
  createdAt: Date
  expiresAt?: Date
type ProjectedNoteShortId =
  id: ObjectId
  shortId: string
type ProjectedNote = Note & ProjectedNoteShortId
type PrintNotesOptions
  disableHeader?: boolean

collection := unless 'auth' is in argv
  createClient()
    |> await |> .connect()
    |> await |> .db 'notiz'
    |> .collection<Note> 'notes'

if collection
  await collection.createIndex { content: 1 }, { unique: true }

NOTE_SHORT_ID_PROJECTION := {
  _id: 0
  id: '$_id'
  shortId: { $substr: [{ $toString: '$_id' }, 21, 24] }
} as const
NOTE_FIND_PROJECTION := Object.assign {
  content: 1
  createdAt: 1
  expiresAt: 1
} as const, NOTE_SHORT_ID_PROJECTION

encoder := new TextEncoder()

lastBytesOf := (value: string, length: number) ->
  encoder
    |> .encode(value)
    |> .slice(-length)

objectIdAlias := (id: ObjectId) ->
  lastBytesOf id.toHexString(), 3
    |> Buffer.from
    |> .toString()

sortBy := (field: string) ->
  (orig: any, comp: any) ->
    unless orig[field] and comp[field]
      0
    else
      orig[field]! > comp[field]! ? 1 : -1

sortByDesc := (field: string) ->
  (orig: any, comp: any) ->
    unless orig[field] and comp[field]
      0
    else
      orig[field]! < comp[field]! ? 1 : -1

formatExpiresAt := (createdAt: dayjs.Dayjs, expires: string) ->
  [time, rawPeriod] := expires
    |> .split /^(\d+)\s*(\w+)$/
    |> .filter Boolean
  unless rawPeriod
    return null
  period := rawPeriod.replace /s$/, ''
  createdAt
    |> .add
      Number time
      period as dayjs.ManipulateType
    |> .toDate()

configure := (args?: ArgumentsCamelCase<{ option?: 'editor' | (string & {}), value?: string }>) : Promise<void> ->
  unless args?.option and args?.value
    logger.error 'No option or value entered'
    exit 1
  currentOptions : NotizOptions := OPTIONS_FILE
    |> .json()
    |> await
  currentOptions[args.option as keyof NotizOptions] = args.value
  logger.success `Option "${args.option}" configured`
  await Bun.write OPTIONS_FILE, JSON.stringify currentOptions

search := (args?: ArgumentsCamelCase<{ content?: string, sort?: string, sortdesc?: string }>) : Promise<void> ->
  unless args?.content
    logger.error 'No search term entered'
    exit 1
  logger.info 'Searching notes...'
  try
    rows := collection!
      |> .find<ProjectedNote>
        { content: $eq: new RegExp args.content, 'i' }
        projection: NOTE_FIND_PROJECTION
      |> .toArray()
      |> await
    await printNotes rows, args
  catch error
    logger.error 'Failed to search notes'
    logger.error (error as Error).message
    exit 1

printNotes := (notesList: WithId<Note>[], args?: ArgumentsCamelCase<{ sort?: string, sortdesc?: string }>, options?: PrintNotesOptions) : Promise<void> ->
  length := notesList.length
  if length is 0
    logger.success C.bold 'No notes found'
    exit 0
  markdown .= ''
  expired : ObjectId[] := []
  rows : WithId<Omit<Note, 'createdAt' | 'expiresAt'> & { createdAt: string; expiresAt: string }>[] .= []
  for { id, content, createdAt, expiresAt } of notesList
    hasExpired := expiresAt and expiresAt < new Date()
    if hasExpired
      expired.push id
    else
      rows.push {
        id
        content
        createdAt: createdAt.toLocaleString()
        expiresAt: expiresAt?.toLocaleString() or ''
      }
  unless expired.length is 0
    logger.warn 'Some notes have expired'
    await collection!.deleteMany
      _id: { $in: expired }
  sort := args?.sort or args?.sortdesc
  isDescending := args?.sortdesc is sort
  if sort and sort is in choices
    rows = (isDescending ? sortByDesc : sortBy) sort |> rows.sort
  unless options?.disableHeader
    stdout.write C.dim '-\n'
    logger.success C.bold 'Notes:'
  for { id, content, createdAt, expiresAt }, index of rows
    markdown += `# ${objectIdAlias id}

${content}

${C.dim 'Created at ' + createdAt.toLocaleString()}
${expiresAt ? C.dim `- Expires at ${expiresAt}` : ''}
${index < length - 1 ? '\n---\n' : ''}`
  markdown
    |> cliMd
    |> stdout.write

listAll := (args?: ArgumentsCamelCase<{ sort?: string, sortdesc?: string }>) : Promise<void> ->
  try
    logger.info 'Loading notes...'
    allNotes := collection!
      |> .find<ProjectedNote> {},
          projection: NOTE_FIND_PROJECTION
      |> .toArray()
      |> await
    await printNotes allNotes, args
  catch error
    logger.error 'Failed to load notes'
    logger.error (error as Error).message
    exit 1

view := (args?: ArgumentsCamelCase<{ id?: string, contentOnly?: boolean }>) : Promise<void> ->
  shortId := args?.id
  unless shortId
    logger.error 'No note ID entered'
    exit 1
  try
    map := await mapShortNotesIds()
    id := map.get shortId
    unless id
      logger.error 'Note not found'
      exit 1
    note := collection!
      |> .findOne<ProjectedNote> { _id: id },
          projection: NOTE_FIND_PROJECTION
      |> await
    unless note
      logger.error 'Note not found'
      exit 1
    if args?.contentOnly
      stdout.write note.content
    else
      await printNotes [note], args, { +disableHeader }
  catch error
    logger.error 'Failed to view note'
    logger.error (error as Error).message
    exit 1

mapShortNotesIds := ->
  allNotes := collection!
    |> .find<ProjectedNoteShortId> {},
        projection: NOTE_SHORT_ID_PROJECTION
    |> .toArray()
    |> await
  map := new Map<string, ObjectId>()
  for note of allNotes
    map.set note.shortId, note.id
  map

deleteByShortIds := (shortIds?: string[]) : Promise<void> ->
  unless shortIds?.length
    logger.error 'No note ID entered'
    exit 1
  shouldDeleteAll := shortIds.length is 1 and shortIds.0 is 'all'
  try
    if shouldDeleteAll
      await collection!.deleteMany {}
      return
    map := await mapShortNotesIds()
    idsToDelete : ObjectId[] := []
    for shortId of shortIds
      if map.has shortId
        idsToDelete.push map.get(shortId)!
    unless idsToDelete.length is 0
      await collection!.deleteMany _id: { $in: idsToDelete }
    await listAll()
  catch error
    logger.error (error as Error).message
    exit 1

update := (args?: ArgumentsCamelCase<{ id?: string; expires?: string }>) : Promise<void> ->
  shortId := args?.id
  unless shortId
    logger.error 'No note ID entered'
    exit 1
  try
    map := await mapShortNotesIds()
    id := map.get shortId
    unless id
      logger.error 'Note not found'
      exit 1
    current := collection!
      |> .findOne<Pick<Note, 'content'>>
        { _id: id }
        projection: { content: 1 }
      |> await
    content := current!.content
      |> openOnEditor
      |> await
    expiresAt := if args?.expires then formatExpiresAt dayjs(), args.expires
    await collection!.updateOne
      { _id: id }
      $set: {
        content,
        ...(expiresAt instanceof Date and { expiresAt })
      }
    await listAll()
  catch error
    switch (error as Error).message
      /UNIQUE constraint/
        logger.error 'Note already exists'
      else
        logger.error (error as Error).message
    exit 1

create := (args?: ArgumentsCamelCase<{ note?: string[]; expires?: string }>) : Promise<void> ->
  createdAt := dayjs()
  expiresAt .= null
  try
    content := switch args?.note
      []
        await openOnEditor()
      [...items]
        items.join ' '
    unless content  
      logger.error 'No note entered'
      exit 1
    expiresAt = if args?.expires then formatExpiresAt createdAt, args.expires
    await collection!.insertOne {
      content,
      createdAt: createdAt.toDate(),
      ...(expiresAt instanceof Date and { expiresAt })
    }
    await listAll()
  catch error
    switch (error as Error).message
      /UNIQUE constraint/
        logger.error 'Note already exists'
      else
        logger.error (error as Error).message
    exit 1

yargs hideBin argv
  |> .scriptName 'notiz'
  |> .usage '$0 <cmd> [options]'
  |> .version
    path.resolve import.meta.dir, 'package.json'
      |> Bun.file
      |> .json()
      |> await
      |> .version
  |> .command 'upgrade', 'Upgrades the command to its latest version',
    ->
    -> 
      upgrade()
      exit 0
  |> .command 'auth', 'Updates the database access configuration',
    ->
    ->
      await auth()
      exit 0
  |> .command 'configure <option> <value>', 'Configures the CLI options',
    (yargs) -> yargs
      |> .positional 'option', {
          choices: ['editor']
          describe: 'Option to configure'
          type: 'string'
        }
      |> .positional 'value', { describe: 'Value to set the option to', type: 'string' }
    (args) ->
      args |> configure |> await
      exit 0
  |> .command 'view <id>', "View a note",
    (yargs) -> yargs
      |> .positional 'id', { describe: 'Note id', type: 'string' }
      |> .option 'content-only', { describe: 'Only view the note content', type: 'boolean', alias: 'c' }
    (args) ->
      args |> view |> await
      exit 0
  |> .command 'search <content>', 'Search notes by content',
    (yargs) -> yargs
      |> .positional 'content', { describe: 'Note content', type: 'string' }
      |> .option 'sort', {
          choices
          describe: 'Field to sort ascending by'
          type: 'string'
        }
      |> .option 'sortdesc', {
          choices
          describe: 'Field to sort descending by'
          type: 'string'
        }
    (args) ->
      args |> search |> await
      exit 0
  |> .command 'list', 'List all notes',
    (yargs) -> yargs
      |> .option 'sort', {
          choices
          describe: 'Field to sort ascending by'
          type: 'string'
        }
      |> .option 'sortdesc', {
          choices
          describe: 'Field to sort descending by'
          type: 'string'
        }
    (args) ->
      args |> listAll |> await
      exit 0
  |> .command 'delete <id...>', 'Delete note(s) by ID(s) ("all" to delete all)',
    (yargs) -> yargs
      |> .positional 'id', { describe: 'Note id', type: 'string', +array }
    (args) ->
      args.id |> deleteByShortIds |> await
      exit 0
  |> .command 'update <id>', 'Update a note',
    (yargs) -> yargs
      |> .positional 'id', { describe: 'Note id', type: 'string' }
      |> .option 'expires', { describe: 'Note expiration time', type: 'string', alias: 'e', -required }
    (args) ->
      args |> update |> await
      exit 0
  |> .command 'create [note...]', 'Create a note',
    (yargs) -> yargs
      |> .positional 'note', { describe: 'Note content', type: 'string', -required, +array }
      |> .option 'expires', { describe: 'Note expiration time', type: 'string', alias: 'e', -required }
    (args) ->
      args |> create |> await
      exit 0
  |> .demandCommand 1
  |> .recommendCommands()
  |> .argv
