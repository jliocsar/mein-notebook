{ env, argv, stdout, stderr, exit } from node:process
fs from node:fs/promises
path from node:path
{ spawn } from node:child_process

type { ArgumentsCamelCase } from yargs
yargs from yargs/yargs
dayjs from dayjs
Table from cli-table3
Cryptify from cryptify
* as C from colorette
{ Spinner } from @topcli/spinner
{ hideBin } from yargs/helpers
{ eq, inArray } from drizzle-orm

type { TDbCredentials } from ./drizzle.config
{ createClient } from ./lib/db/client.civet
{ notes } from ./lib/db/schema

printDimmed := (message: string) -> stdout.write C.dim message + '\n'
printHeader := (message: string) -> stdout.write C.bold message + '\n'
printWaiting := (message: string) -> stdout.write `â³ ${message}\n`
printWarning := (message: string) -> stdout.write `${C.bold C.yellowBright 'âš '} ${message}\n`
printSuccess := (message: string) -> stdout.write `${C.bold C.greenBright 'âœ”'} ${message}\n`
printError := (message: string) -> stderr.write `${C.bold C.redBright 'âŒ'} ${message}\n`

HOME := env.HOME!
SECRET := env.NOTIZ_SECRET!
unless SECRET
  printError `No env. variable ${C.blueBright 'NOTIZ_SECRET'} detected!`
  stdout.write 'Set it to a secret string to encrypt your database auth\n'
  exit 1

MEINE_NOTEBOOK_PATH := path.resolve HOME, '.notiz'
DATABASE_CONFIG_PATH := path.resolve MEINE_NOTEBOOK_PATH, 'database'
BANNER := C.magenta
  `
            .   *#          ..   
    :--     -@*  @@  .:     =---  
    =-=.    +@#  @@  =@+     ::   
            =@# :@%  #@= +.       
            @@#%@@+%@# -@+       
        --   +@@@@@@@@@%@#        
        #@*. =@@@@@@@@@@#         
        *@@@@@@@@@@@@@@          
          =#@@@@@@@@@@=          
    ..:     -%@@@@@@@*           
    .:-      .@@@@@@.   .-+      
              .@@#*#@             
          ++=*##@@@*##=:         
  :.:--#%%%%%%%%%%%%%%%%%#*--.-: 

               ${C.italic C.white 'notiz'}

  `

choices := ['id', 'content', 'createdAt', 'expiresAt']
noop : boolean .= false

process.on 'SIGINT', ->
  printError 'Aborting...'
  exit 0

auth := : Promise<void> ->
  return if noop
  stdout.write BANNER + '\n'
  printWarning 'WARN!'
  stdout.write 'No database config found, asking for one...\n\n'
  printDimmed 'URL of the database:'
  url := readStdin() |> await
  unless url
    printError 'No URL entered'
    exit 1
  printDimmed '\nDatabase auth token:'
  authToken := readStdin() |> await
  unless authToken
    printError '\nNo auth token entered'
    exit 1
  spinner := new Spinner
    |> .start C.cyanBright 'Writing database auth...'

  try
    unless await fs.exists MEINE_NOTEBOOK_PATH
      await fs.mkdir MEINE_NOTEBOOK_PATH
    data := { url, authToken } as TDbCredentials |> JSON.stringify
    await Bun.write DATABASE_CONFIG_PATH, data
    crypt := new Cryptify DATABASE_CONFIG_PATH, SECRET, undefined, 'utf-8', true, true
    await crypt.encrypt()
    noop = true
    spinner.succeed '\nDatabase config saved...\n'
    printWaiting 'Applying database migration...'
    await import './lib/db/migrate.civet'
  catch error
    spinner.failed '\nFailed to write database config\n'
    printError (error as Error).message
    await fs.rm MEINE_NOTEBOOK_PATH, recursive: true
    exit 1

if not await fs.exists DATABASE_CONFIG_PATH
  await auth()

db := unless 'auth' is in argv
  createClient() |> await |> .db

readStdin := ->
  for await chunk of Bun.stdin.stream()
    if chunk
      return chunk |> Buffer.from |> .toString().trim()
  void 0

sortBy := (choice: number) ->
  (orig: any, comp: any) ->
    unless orig[choice] and comp[choice]
      0
    else
      orig[choice]! > comp[choice]! ? 1 : -1

sortByDesc := (choice: number) ->
  (orig: any, comp: any) ->
    unless orig[choice] and comp[choice]
      0
    else
      orig[choice]! < comp[choice]! ? 1 : -1

listAll := (args?: ArgumentsCamelCase<{ sort?: string, sortdesc?: string }>) ->
  spinner := new Spinner |> .start 'Loading notes...'
  table := new Table
    head: ['â˜• ID', 'ðŸ“œ Note', 'ðŸ• Created at', 'ðŸŒ‹ Expires at']
  try
    allNotes := db!.select() |> .from notes |> await
    expired : number[] := []
    rows .= []
    for { id, content, createdAt, expiresAt } of allNotes
      hasExpired := expiresAt and expiresAt < new Date()
      if hasExpired
        expired.push id
      else
        rows.push [
          id
          content
          createdAt.toLocaleString()
          expiresAt?.toLocaleString() ?? '-'
        ]
    unless expired.length is 0
      printWarning 'Some notes have expired'
      await deleteByIds expired
    sort := args?.sort or args?.sortdesc
    isDescending := args?.sortdesc is sort
    if sort and sort is in choices
      choice := choices.indexOf sort
      rows = (isDescending ? sortByDesc : sortBy) choice |> rows.sort
    if rows.length is 0
      spinner.succeed C.bold 'No notes found'
      exit 0
    spinner.succeed C.bold 'Notes:'
    table
      ||> .push ...rows
      |> .toString() + '\n'
      |> stdout.write
  catch error
    spinner.failed 'Failed to load notes'
    printError (error as Error).message
    exit 1
  void 0

deleteByIds := (ids?: (string | number)[]) ->
  unless ids
    printError 'No note ID entered'
    exit 1
  try
    shouldDeleteAll := ids.length is 1
      and ids.0 is 'all'
    db!.delete notes
      |> .where
        shouldDeleteAll
          ? undefined
          : inArray notes.id, ids.map Number
      |> .returning()
      |> await
    unless shouldDeleteAll
      listAll()
  catch error
    printError (error as Error).message
    exit 1
  void 0

update := (id?: number) ->
  unless id
    printError 'No note ID entered'
    exit 1
  printHeader 'Enter note update:'
  content := readStdin() |> await
  unless content
    printError 'No note entered'
    exit 1
  try
    db!.update notes
      |> .set { content }
      |> .where eq notes.id, id
      |> .returning()
      |> await
    listAll()
  catch error
    switch (error as Error).message
      /UNIQUE constraint/
        printError 'Note already exists'
      else
        printError (error as Error).message
    exit 1
  void 0

create := (args?: ArgumentsCamelCase<{ note?: string[]; expires?: string }>) ->
  createdAt := dayjs()
  expiresAt .= null
  content := switch args?.note
    []
      printHeader 'Note content:'
      input := await readStdin()
      printHeader '\nExpires at:'
      expiresAt = readStdin()
        |> await |> (val) ->
          unless val
            return null
          [time, rawPeriod] := val!.split ' '
          unless rawPeriod
            return null
          period := rawPeriod.replace /s$/, ''
          createdAt.add
            Number time
            period as dayjs.ManipulateType
      input
    [...items]
      items.join ' '
  unless content  
    printError 'No note entered'
    exit 1
  try
    db!.insert notes
      |> .values {
          content,
          createdAt: createdAt.toDate(),
          // @ts-expect-error - ts doesn't know js
          ...(expiresAt && {
            expiresAt: (expiresAt as dayjs.Dayjs).toDate()
          })
        }
      |> await
    listAll()
  catch error
    switch (error as Error).message
      /UNIQUE constraint/
        printError 'Note already exists'
      else
        printError (error as Error).message
    exit 1
  void 0

yargs hideBin argv
  |> .scriptName 'notiz'
  |> .usage '$0 <cmd> [options]'
  |> .command 'auth', 'Updates the database access configuration', ->, auth
  |> .command 'list', 'List all notes',
    (yargs) -> yargs
      |> .option 'sort', {
          choices
          describe: 'Field to sort ascending by'
          type: 'string'
        }
      |> .option 'sortdesc', {
          choices
          describe: 'Field to sort descending by'
          type: 'string'
        }
    listAll
  |> .command 'delete <id...>', 'Delete note(s) by ID(s) ("all" to delete all)',
    (yargs) -> yargs
      |> .positional 'id', { describe: 'Note id', type: 'string', array: true }
    (args) -> deleteByIds args.id
  |> .command 'update <id>', 'Update a note',
    (yargs) -> yargs
      |> .positional 'id', { describe: 'Note id', type: 'number' }
    (args) -> update args.id
  |> .command 'create [note...]', 'Create a note',
    (yargs) -> yargs
      |> .positional 'note', { describe: 'Note content', type: 'string', required: false, array: true }
    create
  |> .demandCommand 1
  |> .recommendCommands()
  |> .argv
