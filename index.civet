{ argv, stdout, stderr, exit } from node:process
fs from node:fs/promises
path from node:path

Table from cli-table3
yargs from yargs/yargs
dayjs from dayjs
* as colorette from colorette
{ Spinner } from @topcli/spinner
{ hideBin } from yargs/helpers
{ eq, inArray } from drizzle-orm

type { TDbCredentials } from ./drizzle.config
{ createClient } from ./lib/db/client.civet
{ notes } from ./lib/db/schema

process.on 'SIGINT', ->
  stdout.write colorette.redBright 'Aborting...\n'
  exit 0

MEINE_NOTEBOOK_PATH := '.meine-notebook'
DATABASE_CONFIG_PATH := path.join MEINE_NOTEBOOK_PATH, 'database'
BANNER := colorette.magenta
  `
            .   *#          ..   
    :--     -@*  @@  .:     =---  
    =-=.    +@#  @@  =@+     ::   
            =@# :@%  #@= +.       
            @@#%@@+%@# -@+       
        --   +@@@@@@@@@%@#        
        #@*. =@@@@@@@@@@#         
        *@@@@@@@@@@@@@@          
          =#@@@@@@@@@@=          
    ..:     -%@@@@@@@*           
    .:-      .@@@@@@.   .-+      
              .@@#*#@             
          ++=*##@@@*##=:         
  :.:--#%%%%%%%%%%%%%%%%%#*--.-: 

           ${colorette.italic colorette.white 'mein-notebook'}
  `

noop : boolean .= false

auth := : Promise<void> ->
  return if noop
  stdout.write BANNER + '\n'
  stdout.write colorette.yellowBright 'WARN!\n'
  stdout.write 'No database config found, asking for one...\n\n'

  stdout.write colorette.dim 'URL of the database:\n'
  url := readStdin() |> await
  stdout.write colorette.dim '\nDatabase auth token:\n'
  authToken := readStdin() |> await
  spinner := new Spinner
    |> .start colorette.cyanBright 'Writing database auth...'

  try
    unless await fs.exists MEINE_NOTEBOOK_PATH
      await fs.mkdir MEINE_NOTEBOOK_PATH
    data := { url, authToken } as TDbCredentials |> JSON.stringify
    await Bun.write DATABASE_CONFIG_PATH, data
    noop = true
    spinner.succeed '\nDatabase authenticated...\n'
  catch error
    spinner.failed '\nFailed to write database config\n'
    stderr.write (error as Error).message + '\n'
    await fs.rm MEINE_NOTEBOOK_PATH, recursive: true
    exit 1

if not await fs.exists DATABASE_CONFIG_PATH
  await auth()

db := unless 'auth' is in argv
  createClient() |> await |> .db

readStdin := ->
  for await chunk of Bun.stdin.stream()
    if chunk
      return chunk |> Buffer.from |> .toString().trim()
  null

listAll := ->
  spinner := new Spinner |> .start 'Loading notes...'
  table := new Table
    head: ['ID', 'Content', 'Created at', 'Expires at']
    colWidths: [10, 40, 28, 28]
  try
    allNotes := db!.select() |> .from notes |> await
    console.clear()
    spinner.succeed colorette.bold 'Notes:'
    expired : number[] := []
    for { id, content, createdAt, expiresAt } of allNotes
      hasExpired := expiresAt and expiresAt < new Date()
      if hasExpired
        expired.push id
      else
        table.push [
          id
          content
          createdAt.toLocaleString()
          expiresAt?.toLocaleString()
        ]
    unless expired.length is 0
      stdout.write colorette.cyanBright 'Some notes have expired\n'
      await deleteByIds expired
    table
      |> .toString()
      |> (str) -> stdout.write str + '\n'
  catch error
    spinner.failed 'Failed to load notes'
    stderr.write (error as Error).message + '\n'
    exit 1
  void 0

deleteByIds := (ids?: (string | number)[]) ->
  unless ids
    stderr.write 'No note ID entered\n'
    exit 1
  try
    shouldDeleteAll := ids.length is 1
      and ids.0 is 'all'
    db!.delete notes
      |> .where
        shouldDeleteAll
          ? undefined
          : inArray notes.id, ids.map Number
      |> .returning()
      |> await
    listAll()
  catch error
    stderr.write (error as Error).message + '\n'
    exit 1
  void 0

update := (id?: number) ->
  unless id
    stderr.write 'No note ID entered\n'
    exit 1
  stdout.write 'Enter note update: \n'
  content := readStdin() |> await
  unless content
    stderr.write 'No note entered\n'
    exit 1
  try
    db!.update notes
      |> .set { content }
      |> .where eq notes.id, id
      |> .returning()
      |> await
    listAll()
  catch error
    stderr.write (error as Error).message + '\n'
    exit 1
  stdout.write '1'
  void 0

create := ->
  stdout.write colorette.bold 'Enter note: \n'
  content := readStdin() |> await
  stdout.write colorette.bold '\nExpires at: \n'
  createdAt := dayjs()
  expiresAt := readStdin()
    |> await |> (val) ->
      unless val
        return null
      [time, rawPeriod] := val!.split ' '
      unless rawPeriod
        return null
      period := rawPeriod.replace /s$/, ''
      createdAt.add
        Number time
        period as dayjs.ManipulateType
  unless content  
    stderr.write 'No note entered\n'
    exit 1
  try
    db!.insert notes
      |> .values {
          content,
          createdAt: createdAt.toDate(),
          expiresAt: expiresAt?.toDate()
        }
      |> await
    listAll()
  catch error
    stderr.write (error as Error).message + '\n'
    exit 1
  stdout.write '1'
  void 0

yargs hideBin argv
  |> .scriptName 'mein-notes'
  |> .usage '$0 <cmd> [options]'
  |> .command 'auth', 'Authorizes the CLI tool to access the database', ->, auth
  |> .command 'upgrade', 'Upgrades the CLI tool to its last version', ->, ->
    stdout.write BANNER + '\n'
    stdout.write 'Fetching last version...\n'
    void 0
  |> .command 'list', 'List all notes', ->, listAll
  |> .command 'delete <id...>', 'Delete a note',
    (yargs) -> yargs
      |> .positional 'id', { describe: 'Note id', type: 'string', array: true }
    (args) -> deleteByIds args.id
  |> .command 'update <id>', 'Update a note',
    (yargs) -> yargs
      |> .positional 'id', { describe: 'Note id', type: 'number' }
    (args) -> update args.id
  |> .command 'create', 'Create a note', ->, create
  |> .demandCommand 1
  |> .recommendCommands()
  |> .argv
